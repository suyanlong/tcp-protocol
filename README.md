# tcp-protocol
学习TCP遇到的问题

## 基于tcp的协议，分包、粘包、黏包的事儿，

搜索tcp协议`分包`，`黏包`，`粘包`这些关键字的，答案要么是不全面，要么是照本宣科，没有实际经验。比如：HTTP协议不需要分包。TCP协议是流协议，不需要分包。

没有一点实际意义，甚至是无人子弟。

今天我就给大家详细的说一下这里面的概念。

## TCP协议本身是没有包的概念
因为TCP协议是流协议，TCP协议本身是没有包概念的，但是在实际的实现库中，却存在各种限制问题需要应对。

比如：
调用socket read读取协议栈buffer(socket)的时候，读取的是（一块）字节流（package），每次读取的字节流(package)大小是不一样的，

因为这个package可能是半个、或者多个、多个半的业务包，

因此我们所说的包其实是业务逻辑包（业务逻辑字节流），

协议怎么知道每次读取都是一个完整的`业务包`？怎么解析这一份字节流？如果不完整是否需要丢弃？

怎么解析读取过来的package呢？这个时候你就要自己设计自己的业务包的大小了。

## 解决`分包、粘包、黏包`手段
不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。
但在实际工程应用中，传输的数据一般为带结构的数据，这时就需要做分包处理。

## 消息边界的解决
1. 发送固定长度的消息

2. 把消息的尺寸与消息一块发送

3. 使用特殊标记来区分消息间隔

4. header + body(自定义协议)

## 自定义协议
header + body自定义协议),
自定义协议各个字段的意义，
buffer大小限制。
业务逻辑结构化的包大小限制。

### 封包
封包就是给一段数据加上包头,这样一来数据包就分为包头和包体两部分内容了(以后讲过滤非法包时封包会加入"包尾"内容)。

包头其实上是个大小固定的结构体，其中有个结构体成员变量表示包体的长度，这是个很重要的变量，其他的结构体成员可根据需要自己定义。

根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的业务数据包。

### 拆包
对于拆包目前我最常用的是以下两种方式：

#### 动态缓冲区暂存方式。之所以说缓冲区是动态的是因为当需要缓冲的数据长度超出缓冲区的长度时会增大缓冲区长度。

大概过程描述如下:

A,为每一个连接动态分配一个缓冲区,同时把此缓冲区（应用层buffer）和SOCKET关联,常用的是通过结构体关联.

B,当接收到数据时首先把此段数据存放在缓冲区中.

C,判断缓存区中的数据长度是否够一个包头的长度,如不够,则不进行拆包操作.

D,根据包头数据解析出里面代表包体长度的变量.

E,判断缓存区中除包头外的数据长度是否够一个包体的长度,如不够,则不进行拆包操作.

F,取出整个数据包.这里的"取"的意思是不光从缓冲区中拷贝出数据包,而且要把此数据包从缓存区中删除掉.删除的办法就是把此包后面的数据移动到缓冲区的起始地址.

这种方法有两个缺点.

1. 为每个连接动态分配一个缓冲区增大了内存的使用.

2. 有三个地方需要拷贝数据,一个地方是把数据存放在缓冲区,一个地方是把完整的数据包从缓冲区取出来,一个地方是把数据包从缓冲区中删除.第二种拆包的方法会解决和完善这些缺点.

前面提到过这种方法的缺点.下面给出一个改进办法, 即采用环形缓冲.但是这种改进方法还是不能解决第一个缺点以及第一个数据拷贝,只能解决第三个地方的数据拷贝(这个地方是拷贝数据最多的地方).第2种拆包方式会解决这两个问题.

环形缓冲实现方案是定义两个指针,分别指向有效数据的头和尾.在存放数据和删除数据时只是进行头尾指针的移动.

#### 利用底层的缓冲区来进行拆包
由于TCP也维护了一个缓冲区,所以我们完全可以利用TCP的缓冲区来缓存我们的数据，这样一来就不需要为每一个连接分配一个缓冲区了。另一方面我们知道recv或者wsarecv都有一个参数,用来表示我们要接收多长长度的数据。利用这两个条件我们就可以对第一种方法进行优化。

对于阻塞SOCKET来说，我们可以利用一个循环来接收包头长度的数据，然后解析出代表包体长度的那个变量，再用一个循环来接收包体长度的数据。

### 为什么要限制应用层buffer的大小？
1. 一个socket绑定一个buffer,如果成千上万socket连接，内存会吃不消的，会导致内存溢出。
2. 如果别人发送网络协议攻击，会导致内存溢出。比如，发送一个大结构化的数据，就会导致内存溢出，因此需要限制buffer大小。

## 网络交互需要关心的问题
只要是基于TCP协议的，需要结构化的业务逻辑包，都需要需要大小限制，这个限制就是限制buffer的最小限制，同时buffer也要有最大限制。

包最大大小 < buffer大小 < 多个包最大大小

## HTTP协议需要注意`包`的大小吗？
而我们一般说的HTTP协议是基于TCP实现的，因此也要处理每一次读取TCP协议栈（socket buffer）的`包`(pacage)问题，比如，接收POST数据，读取协议栈buffer(socket)的package大小是多少？这个包是不是完整的应用层业务逻辑包？怎么解析？每一家公司的业务逻辑包都不一样，所以大小也都不一样。因此分包、粘包都是业务层的事情，与HTTP协议、TCP协议本身没有关系。

当然HTTP也提供了一个chunked，用于分块传输。

但是，作为实现HTTP协议、TCP协议的库，从socket buffer读取的数据（因为这个数据可能不是完整业务逻辑包）都会事先缓存到应用层的一个buffer里面，这个应用层缓存buffer的大小一定要有限制！为什么要限制？如果你不限制，别人攻击了，会造成内存溢出问题！

如果说，应用层缓存buffer大小是否限制是考核库的标准之一，那么判断一个协议库是不是做的很优雅，就要看这个参数，有没有提供给库的调用方可设置。

在一些HTTP协议库中，这个buffer一般都设置死了，defaut大小一般是0.4M（一般的业务包大小，也不会大于这个数了）左右，并且很少有给外界修改这个参数方法，如果你要传输大文件，请使用chunked机制。

因此，那些说HTTP不用分包的，估计也是半懂不懂，不用chunked机制，你试试传送100M的数据，你能传输不？

那些整天说TCP协议是流协议的，不用分包的，你们都是照本宣科吧，TCP协议本身确实没有包的概念，但是你们有没有亲自实现一个二进制协议的？遇到过这种场景么（读取socket buffer的数据不是一个完整的业务包，怎么处理的问题），就在这类瞎歪歪的，误人子弟。

因此，基于TCP的协议的，黏包、分包概念指都是自己业务层逻辑包，与协议本身无关。

一句话总结，不合符HTTP协议请求的缓存（到buffer里面）起来，继续接收数据，然后再验证，直到是一个完整的HTTP请求。这种是一个完整HTTP请求或应答数据，分了两次从socket buffer里面读取出来。

